---
description: 使用 Changesets (npm run changeset) 管理版本和更新日志的指南
alwaysApply: true
---

# Changesets 工作流指南

Changesets 用于管理包版本并自动生成准确的 `CHANGELOG.md` 文件。在进行影响包的外部视角或显著影响其他地方记录的内部开发工作流的重要更改后,正确使用它至关重要。

## 何时运行 Changeset

- 在暂存(`git add .`)一组应在下一个版本的 `CHANGELOG.md` 中说明的逻辑更改**之后**运行 `npm run changeset` (或 `npx changeset add`)。
- 这通常包括:
    - **新功能** (向后兼容的添加)
    - **Bug 修复** (修复现有功能)
    - **破坏性更改** (不向后兼容的更改)
    - **性能改进** (速度或资源使用的增强)
    - **重大重构** (主要代码重组,即使外部行为未改变,因为可能影响稳定性或可维护性) - *例如将 MCP 服务器的直接函数实现重组到单独的文件中*
    - **面向用户的文档更新** (对 README、使用指南、公共 API 文档的更改)
    - **依赖更新** (特别是修复已知问题或引入重大更改)
    - **构建/工具更改** (如果影响消费者如何构建或与包交互)
- 包含上述一个或多个更改类型的**每个 Pull Request** **都应包含一个 changeset 文件**。

## 不需要添加 Changeset 的情况

避免为对 `task-master` 包的外部消费者或遵循**面向公众的文档**的贡献者**没有影响或相关性**的更改创建 changesets。例如:

- **内部文档更新:** 仅对 `.cursor/rules/` 内仅指导此特定存储库内部开发实践的文件的更改。
- **琐碎的杂务:** 非常小的代码清理、添加不澄清行为的注释、非面向用户代码或内部文档中的拼写错误修复。
- **无影响的测试更新:** 测试的小重构、为现有功能添加测试而不修复 bug。
- **本地配置更改:** 个人编辑器设置、本地 `.env` 文件等的更新。

**经验法则:** 如果安装或使用 `task-master` 包的用户不会关心该更改,或者如果遵循主 README 的贡献者不需要了解其工作流程,您可能不需要 changeset。

## 如何运行及其询问内容

1.  **运行命令**:
    ```bash
    npm run changeset
    # 或
    npx changeset add
    ```
2.  **选择包**: 它将提示您使用方向键和空格键选择受更改影响的包。如果这不是 monorepo,请选择主包。
3.  **选择版本升级类型**: 为**每个**选定的包选择适当的语义版本升级:
    *   **`Major`**: 用于**破坏性更改**。谨慎使用。
    *   **`Minor`**: 用于**新功能**。
    *   **`Patch`**: 用于**bug 修复**、性能改进、**面向用户的文档更改**、重大重构、相关依赖更新或有影响的构建/工具更改。
4.  **输入摘要**: 为 `CHANGELOG.md` 提供更改的简明摘要。
    *   **目的**: 此消息面向用户,解释版本中*更改了什么*。
    *   **格式**: 使用祈使语气(例如,"添加功能 X"、"修复 bug Y"、"更新 README 设置说明")。保持简短,通常一行足够。
    *   **受众**: 考虑安装/更新包的用户或使用其公共 API/CLI 的开发人员。
    *   **不是 Git 提交消息**: 此摘要与您详细的 Git 提交消息*不同*。

## Changeset 摘要与 Git 提交消息

- **Changeset 摘要**:
    - **受众**: 包的用户/消费者(阅读 `CHANGELOG.md`)。
    - **目的**: 简要描述发布版本中与他们相关的*更改内容*。
    - **格式**: 简洁、祈使语气,通常一行足够。
    - **示例**: `修复 'next' 命令中的依赖解析 bug。`
- **Git 提交消息**:
    - **受众**: 浏览*此*存储库 Git 历史的开发人员。
    - **目的**: 解释进行更改的*原因*、上下文和实现细节(可以包括内部上下文)。
    - **格式**: 遵循提交约定(例如,Conventional Commits),可以是带有主题和正文的多行。
    - **示例**:
      ```
      fix(deps): 修正 'next' 命令中的依赖查找

      之前的逻辑在确定下一个可用任务时未考虑子任务依赖。
      此提交重构了 `task-manager.js` 中 `findNextTask` 的
      依赖检查,以正确遍历直接和子任务依赖。添加了单元
      测试以覆盖此特定场景。
      ```
- ✅ **应该**: 提供*同时*简明的 changeset 摘要(在适当时)和详细的 Git 提交消息。
- ❌ **不应该**: 将详细的 Git 提交消息正文用作 changeset 摘要。
- ❌ **不应该**: 因为写了一个好的提交消息就跳过为用户相关更改运行 `changeset`。

## `.changeset` 文件

- 运行命令会在 `.changeset/` 目录中创建一个唯一的 markdown 文件(例如,`.changeset/random-name.md`)。
- 此文件包含版本升级类型信息和您提供的摘要。
- **此文件必须与相关代码更改一起暂存和提交**。

## 标准工作流程序(需要 Changeset 时)

1.  进行代码或相关文档更改。
2.  暂存更改: `git add .`
3.  运行 changeset: `npm run changeset`
    *   选择包。
    *   选择版本升级类型(`Patch`、`Minor`、`Major`)。
    *   输入用于更新日志的**简明摘要**。
4.  暂存生成的 changeset 文件: `git add .changeset/*.md`
5.  使用**详细的 Git 提交消息**提交所有暂存的更改(代码 + changeset 文件):
    ```bash
    git commit -m "feat(module): 添加新功能 X..."
    ```

## 发布流程(上下文)

- 生成的 `.changeset/*.md` 文件稍后在发布过程中被使用。
- 像 `changeset version` 这样的命令会读取这些文件,更新 `package.json` 版本,更新 `CHANGELOG.md`,并删除单个 changeset 文件。
- 像 `changeset publish` 这样的命令然后将新版本发布到 npm。

遵循此工作流程可确保版本控制一致,并根据所做的贡献自动准确地生成更新日志。
